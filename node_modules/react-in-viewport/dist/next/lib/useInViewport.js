// React hooks
// eslint-disable-next-line no-unused-vars
import { useEffect, useRef, useState, MutableRefObject } from 'react';
import { findDOMNode } from 'react-dom';
import { defaultOptions, defaultConfig, defaultProps } from './constants';
/**
 *
 * @param {MutableRefObject} target
 * @param {IntersectionObserverInit} [options = defaultOptions]
 * @param {Object} [config = defaultConfig]
 * @param {boolean} [config.disconnectOnLeave = false]
 * @param {Object} [props = defaultProps]
 * @param {VoidFunction} [props.onEnterViewport = noop]
 * @param {VoidFunction} [props.onLeaveViewport = noop]
 * @returns {Object} returnObject
 * @returns {boolean} returnObject.inViewport
 * @returns {number} returnObject.enterCount
 * @returns {number} returnObject.leaveCount
 */

var useInViewport = function useInViewport(target, options, config, props) {
  if (options === void 0) {
    options = defaultOptions;
  }

  if (config === void 0) {
    config = defaultConfig;
  }

  if (props === void 0) {
    props = defaultProps;
  }

  var _props = props,
      onEnterViewport = _props.onEnterViewport,
      onLeaveViewport = _props.onLeaveViewport;

  var _useState = useState(),
      forceUpdate = _useState[1];

  var observer = useRef();
  var inViewportRef = useRef(false);
  var intersected = useRef(false);
  var enterCountRef = useRef(0);
  var leaveCountRef = useRef(0);

  function startObserver(_ref) {
    var observerRef = _ref.observerRef;
    var targetRef = target.current;

    if (targetRef) {
      var node = findDOMNode(targetRef);

      if (node) {
        observerRef == null ? void 0 : observerRef.observe(node);
      }
    }
  }

  function stopObserver(_ref2) {
    var observerRef = _ref2.observerRef;
    var targetRef = target.current;

    if (targetRef) {
      var node = findDOMNode(targetRef);

      if (node) {
        observerRef == null ? void 0 : observerRef.unobserve(node);
      }
    }

    observerRef == null ? void 0 : observerRef.disconnect();
    observer.current = null;
  }

  function handleIntersection(entries) {
    var entry = entries[0] || {};
    var isIntersecting = entry.isIntersecting,
        intersectionRatio = entry.intersectionRatio;
    var isInViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0; // enter

    if (!intersected.current && isInViewport) {
      intersected.current = true;
      onEnterViewport && onEnterViewport();
      enterCountRef.current += 1;
      inViewportRef.current = isInViewport;
      forceUpdate(isInViewport);
      return;
    } // leave


    if (intersected.current && !isInViewport) {
      intersected.current = false;
      onLeaveViewport && onLeaveViewport();

      if (config.disconnectOnLeave && observer.current) {
        // disconnect obsever on leave
        observer.current.disconnect();
      }

      leaveCountRef.current += 1;
      inViewportRef.current = isInViewport;
      forceUpdate(isInViewport);
    }
  }

  function initIntersectionObserver(_ref3) {
    var observerRef = _ref3.observerRef;

    if (!observerRef) {
      // $FlowFixMe
      observer.current = new IntersectionObserver(handleIntersection, options);
      return observer.current;
    }

    return observerRef;
  }

  useEffect(function () {
    var observerRef = observer.current; // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

    observerRef = initIntersectionObserver({
      observerRef: observerRef
    });
    startObserver({
      observerRef: observerRef
    });
    return function () {
      stopObserver({
        observerRef: observerRef
      });
    };
  }, [target.current, options, config, onEnterViewport, onLeaveViewport]);
  return {
    inViewport: inViewportRef.current,
    enterCount: enterCountRef.current,
    leaveCount: leaveCountRef.current
  };
};

export default useInViewport;